-- 1. Deleting existing objects (safer alternative).
DROP SCHEMA IF EXISTS bank_system CASCADE;
CREATE SCHEMA bank_system;
SET search_path TO bank_system;

-- 2. Creating tables with modern syntax
CREATE DOMAIN phone_number AS VARCHAR(20)
CHECK (VALUE ~ '^\+?[0-9]{7,15}$');

CREATE DOMAIN email_type AS VARCHAR(100)
CHECK (VALUE ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

CREATE TABLE clients (
    client_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    passport_number VARCHAR(20) UNIQUE NOT NULL,
    phone phone_number UNIQUE NOT NULL,
    email email_type UNIQUE NOT NULL,
    registration_date DATE DEFAULT CURRENT_DATE
);

-- Index for frequent searches by name
CREATE INDEX idx_clients_name ON clients (last_name, first_name);

-- 3. Reference tables
CREATE TABLE operation_types (
    operation_type_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    is_income BOOLEAN NOT NULL,
    needs_approval BOOLEAN DEFAULT FALSE
);

-- 4. Improved account structure
CREATE TABLE accounts (
    account_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    client_id INT NOT NULL REFERENCES clients(client_id) ON DELETE CASCADE,
    balance NUMERIC(15, 2) DEFAULT 0.00 CHECK (balance >= 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
    opened_date DATE NOT NULL DEFAULT CURRENT_DATE,
    closed_date DATE CHECK (closed_date IS NULL OR closed_date > opened_date),
    status VARCHAR(20) DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'FROZEN', 'CLOSED'))
);

-- 5. Transactions with improved validation
CREATE TABLE transactions (
    transaction_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    from_account_id INT REFERENCES accounts(account_id),
    to_account_id INT NOT NULL REFERENCES accounts(account_id),
    amount NUMERIC(15, 2) NOT NULL CHECK (amount > 0),
    operation_type INT NOT NULL REFERENCES operation_types(operation_type_id),
    transaction_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    description TEXT,
    status VARCHAR(20) DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'COMPLETED', 'CANCELED'))
);

CREATE OR REPLACE FUNCTION check_transaction()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.from_account_id IS NOT NULL AND (SELECT is_income FROM operation_types WHERE operation_type_id = NEW.operation_type) = TRUE) THEN
        RAISE EXCEPTION 'Invalid operation: income transaction cannot have from_account_id';
    ELSIF (NEW.from_account_id IS NULL AND (SELECT is_income FROM operation_types WHERE operation_type_id = NEW.operation_type) = FALSE) THEN
        RAISE EXCEPTION 'Invalid operation: expense transaction must have from_account_id';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_transaction_trigger
BEFORE INSERT OR UPDATE ON transactions
FOR EACH ROW EXECUTE FUNCTION check_transaction();

-- 6. Secure card storage
CREATE TABLE cards (
    card_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    account_id INT NOT NULL REFERENCES accounts(account_id) ON DELETE CASCADE,
    card_number CHAR(16) UNIQUE NOT NULL CHECK (card_number ~ '^[0-9]{16}$'),
    expiry_date DATE NOT NULL CHECK (expiry_date > CURRENT_DATE),
    is_blocked BOOLEAN NOT NULL DEFAULT FALSE,
    issue_date DATE NOT NULL DEFAULT CURRENT_DATE
);

-- 7. Extended trigger with error handling
CREATE OR REPLACE FUNCTION process_transaction()
RETURNS TRIGGER AS $$
DECLARE
    op_type RECORD;
BEGIN
    SELECT * INTO op_type FROM operation_types
    WHERE operation_type_id = NEW.operation_type;

    IF op_type.is_income THEN
        UPDATE accounts
        SET balance = balance + NEW.amount
        WHERE account_id = NEW.to_account_id;
    ELSE
        UPDATE accounts
        SET balance = balance - NEW.amount
        WHERE account_id = NEW.from_account_id;
    END IF;

    NEW.status := 'COMPLETED';
    RETURN NEW;

EXCEPTION
    WHEN others THEN
        NEW.status := 'CANCELED';
        RAISE NOTICE 'Transaction failed: %', SQLERRM;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER transaction_processing
AFTER INSERT ON transactions
FOR EACH ROW EXECUTE FUNCTION process_transaction();

-- 8. Example usage of CTE for data insertion
WITH new_clients AS (
    INSERT INTO clients (first_name, last_name, passport_number, phone, email)
    VALUES
        ('Ivan', 'Petrov', '1234567890', '+79001234567', 'ivan.petrov@example.com'),
        ('Maria', 'Sidorova', '0987654321', '+79007654321', 'maria.sidorova@example.com')
    RETURNING client_id
),
new_accounts AS (
    INSERT INTO accounts (client_id, balance)
    SELECT client_id, 150000.00 FROM new_clients
    UNION ALL
    SELECT client_id, 50000.00 FROM new_clients
    RETURNING account_id
)
INSERT INTO cards (account_id, card_number, expiry_date)
SELECT
    account_id,
    lpad((random()*10000000000000000)::bigint::text, 16, '0'),
    CURRENT_DATE + INTERVAL '3 years'
FROM new_accounts;

-- Output the contents of the clients table
SELECT * FROM clients;

-- Output the contents of the operation_types table
SELECT * FROM operation_types;

-- Output the contents of the accounts table
SELECT * FROM accounts;

-- Output the contents of the transactions table
SELECT * FROM transactions;

-- Output the contents of the cards table
SELECT * FROM cards;